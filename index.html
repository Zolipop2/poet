<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Poetry Generator (RNN)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 700px;
      margin: auto;
    }
    textarea {
      width: 100%;
      height: 120px;
      margin-top: 10px;
      font-size: 16px;
    }
    input, button {
      font-size: 16px;
      padding: 8px;
      margin-top: 8px;
    }
    #insights {
      background: #f9f9f9;
      border: 1px solid #ccc;
      padding: 10px;
      font-family: monospace;
      font-size: 14px;
      white-space: pre-wrap;
      height: 200px;
      overflow-y: auto;
      margin-top: 12px;
    }
  </style>
</head>
<body>
  <h1>Poetry Generator</h1>

  <label for="startText">Start text (space separated words):</label><br />
  <input id="startText" type="text" value="to be or not to be" /><br />

  <label for="tempInput">Temperature (0.1 - 2.0):</label><br />
  <input id="tempInput" type="number" min="0.1" max="2" step="0.1" value="0.8" /><br />

  <button id="generateBtn" disabled>Loading model...</button>

  <textarea id="output" readonly placeholder="Generated poetry will appear here..."></textarea>

  <h3>Prediction Details</h3>
  <div id="insights">Prediction scores will appear here...</div>

  <script>
    (async () => {
      let model = null;
      let vocab = null;
      let vocabSize = 0;
      const hiddenSize = 64;

      function tanh(x) { return Math.tanh(x); }
      function softmax(arr) {
        const maxVal = Math.max(...arr);
        const exps = arr.map(x => Math.exp(x - maxVal));
        const sum = exps.reduce((a, b) => a + b, 0);
        return exps.map(e => e / sum);
      }
      function sampleWithTemperature(probs, temperature = 1.0) {
        if (temperature <= 0) {
          return probs.indexOf(Math.max(...probs));
        }
        const logProbs = probs.map(p => Math.log(Math.max(p, 1e-8)) / temperature);
        const maxLog = Math.max(...logProbs);
        const exps = logProbs.map(lp => Math.exp(lp - maxLog));
        const sum = exps.reduce((a, b) => a + b, 0);
        const scaledProbs = exps.map(e => e / sum);
        let r = Math.random();
        let cumSum = 0;
        for (let i = 0; i < scaledProbs.length; i++) {
          cumSum += scaledProbs[i];
          if (r < cumSum) return i;
        }
        return scaledProbs.length - 1;
      }
      function oneHot(index, size) {
        const vec = new Array(size).fill(0);
        vec[index] = 1;
        return vec;
      }

      async function loadResources() {
        const [modelResp, vocabResp] = await Promise.all([
          fetch('poetry_model.json'),
          fetch('vocab.json')
        ]);
        model = await modelResp.json();
        vocab = await vocabResp.json();
        vocabSize = Object.keys(vocab.idx_to_word).length;
      }

      function forwardStep(xIndex, hPrev) {
        const x = oneHot(xIndex, vocabSize);
        const h = new Array(hiddenSize).fill(0);
        for (let j = 0; j < hiddenSize; j++) {
          let sumWxh = 0;
          for (let i = 0; i < vocabSize; i++) sumWxh += model.Wxh[i][j] * x[i];
          let sumWhh = 0;
          for (let i = 0; i < hiddenSize; i++) sumWhh += model.Whh[i][j] * hPrev[i];
          h[j] = tanh(sumWxh + sumWhh + model.bh[j]);
        }
        const y = new Array(vocabSize).fill(0);
        for (let j = 0; j < vocabSize; j++) {
          for (let i = 0; i < hiddenSize; i++) y[j] += model.Why[i][j] * h[i];
          y[j] += model.by[j];
        }
        const p = softmax(y);
        return { p, h };
      }

      function warmUpHiddenState(tokens) {
        let h = new Array(hiddenSize).fill(0);
        for (const token of tokens) {
          const idx = vocab.word_to_idx[token];
          h = forwardStep(idx, h).h;
        }
        return h;
      }

      function generateFromPrompt(promptText, length = 60, temperature = 0.8) {
        const promptTokens = promptText.trim().toLowerCase().split(/\s+/);
        const insights = document.getElementById('insights');
        insights.textContent = "";

        for (const token of promptTokens) {
          if (!(token in vocab.word_to_idx)) {
            return `❌ Token "${token}" not in vocabulary.`;
          }
        }

        let h = warmUpHiddenState(promptTokens);
        let currentIndex = vocab.word_to_idx[promptTokens[promptTokens.length - 1]];
        const result = [...promptTokens];

        for (let i = 0; i < length; i++) {
          const { p, h: newH } = forwardStep(currentIndex, h);
          h = newH;

          const top = p.map((prob, idx) => ({ word: vocab.idx_to_word[idx], prob }))
                       .sort((a, b) => b.prob - a.prob)
                       .slice(0, 5);
          insights.textContent += `Step ${i + 1} → ` +
            top.map(w => `${w.word} (${(w.prob * 100).toFixed(1)}%)`).join(", ") + "\n";

          const nextIndex = sampleWithTemperature(p, temperature);
          currentIndex = nextIndex;
          result.push(vocab.idx_to_word[nextIndex]);
        }

        return result.join(" ");
      }

      await loadResources();

      const btn = document.getElementById('generateBtn');
      const output = document.getElementById('output');
      const startInput = document.getElementById('startText');
      const tempInput = document.getElementById('tempInput');

      btn.textContent = 'Generate';
      btn.disabled = false;

      btn.addEventListener('click', () => {
        const startText = startInput.value.trim().toLowerCase();
        const temp = parseFloat(tempInput.value);
        if (isNaN(temp) || temp < 0.1 || temp > 2.0) {
          alert("Temperature must be between 0.1 and 2.0");
          return;
        }
        output.value = "Generating...";
        setTimeout(() => {
          output.value = generateFromPrompt(startText, 100, temp);
        }, 10);
      });
    })();
  </script>
</body>
</html>
